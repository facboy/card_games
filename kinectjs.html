
<!DOCTYPE HTML>
<html>
<head>
    <style>
        body {
            margin: 0px;
            padding: 0px;
        }
        canvas {
            border: 1px solid #9C9898;
        }
    </style>
    <script type="text/javascript" src="lib/underscore-min.js"></script>
  <script type="text/javascript" src="lib/backbone-min.js"></script>

    <script src="http://www.html5canvastutorials.com/libraries/kinetic-v3.9.6.js"></script>
    <script src="src/CardGame.js"></script>
    <script>

        var CardGame = CardGame || {};

        CardGame.Stage = function(ui, options){
            var stage = {}, layer = new Kinetic.Layer(),
                    internalStage = new Kinetic.Stage(options),
                    collisionDetection = CardGame.CollisionDetection(),
                    components = [], listeners = {};

            stage.draw = function(){
                layer.draw();
            };

            stage.add = function(gameComponent){
                layer.add(gameComponent.getComponent());
                components.push(gameComponent);
            };

            stage.remove = function(gameComponent){
                layer.remove(gameComponent.getComponent());
                console.log("removing");
                layer.draw();
            };

            stage.detectCollisions = function(gameComponent){
                collisionDetection.detectCollision(gameComponent, components);
            };

            stage.notifyCurrentCollision = function(gameComponent){
                var destroy = collisionDetection.notifyCurrentCollision(gameComponent);
                console.log("destroy? "+destroy);
                destroy && gameComponent.destroy();
            };

            internalStage.add(layer);

            ui.on("GroupCreated", function(groupId){
                console.log("group "+groupId+" created");
                stage.add(CardGame.Group(stage, ui, {
                    x: 10,
                    y: 10,
                    groupId: groupId,
                    cards: []
                }))
            });

            return stage;
        };

        CardGame.Collisionable = function(stage, component){
            component.getComponent().on("dragmove", function(){
                stage.detectCollisions(component);
            });
            component.getComponent().on("dragstart", function(){
                component.getComponent().moveToTop();
            });
            component.getComponent().on("dragend", function(){
                stage.notifyCurrentCollision(component);
            });
        };

        CardGame.Group = function(stage, ui, options) {
            var group = {}, cards = [],
            groupComponent = new Kinetic.Rect({
                x: options.x,
                y: options.y,
                height: 106,
                fill: "#FFFFFF",
                stroke: "#CCCCCC",
                strokeWidth: 2,
                draggable: true
            }),
            addCard = function(cardId){
                var card = CardGame.Card(stage, ui, {
                    image: cardId,
                    group: group
                });
                cards.push(card);
            },
            // seems a little slow, it seems plausible that it'll actually be faster to group on dragstart and ungroup on dragend
            redrawInternals = function(){
                group.getComponent().setWidth(calculatedWidth(cards.length));
                group.getComponent().setAlpha(calculatedAlpha(cards.length));

                for (var i = 0; i < cards.length; i++) {
                    var card = cards[i].getComponent();
                    card.setX(calculatedX(i, groupComponent.getX()));
                    card.setY(calculatedY(i, groupComponent.getY()));
                    card.moveToTop();
                }
            },
            calculatedX = function(cardIndex, boundingX) {
                return cardIndex * 15 + 5 + boundingX;
            },
            calculatedY = function(cardIndex, boundingY) {
                return 5 + boundingY;
            },
            calculatedWidth = function(cardCount) {
                return 82 + ((cardCount - 1) * 15);
            },
            calculatedAlpha = function(cardCount) {
                return (cards.length > 1 ? 1 : 0);
            };

            group.getComponent = function(){
                return groupComponent;
            };

            group.onCollisionStart = function(model){
            };

            groupComponent.on("dragmove", function(){
                redrawInternals();
            });

            group.onCollisionStop = function(model){
            };

            group.onCollisionAccepted = function(model){
            };

            ui.on("CardAdded:"+options.groupId, function(cardId){
                console.log("Added "+cardId);
                addCard(cardId);
                redrawInternals();
            });

            ui.on("CardRemoved:"+options.groupId, function(cardId){
                console.log("Removed "+cardId);
                group.remove(cardId);
            });

            group.getPoints = function(){
                return {
                    top:groupComponent.getY(),
                    left:groupComponent.getX(),
                    right:groupComponent.getX() + groupComponent.getWidth(),
                    bottom:groupComponent.getY() + groupComponent.getHeight()
                };
            };

            group.getModel = function(){
                return { group_id: "group_" + options.cards.join("_") };
            };

            group.remove = function(card) {
                var ix = cards.indexOf(card);
                cards.splice(ix, 1);
                if (cards.length == 0) {
                    group.destroy();
                }
                else {
                    redrawInternals();
                }
            };

            group.destroy = function(){
                stage.remove(group);
            };

            CardGame.Collisionable(stage, group);

            stage.add(group);

            return group;
        };

        CardGame.Card = function(stage, ui, options){
            var card = {},
            imageObj = new Image(),
            group = options.group,
            image = new Kinetic.Image({
                x: options.x,
                y: options.y,
                width: 72,
                height: 96,
                draggable: true
            });

            imageObj.onload = function() {
                image.setImage(imageObj);
                stage.draw();
            };

            imageObj.src = "cards/classic-cards/"+options.image+".png";

            image.on("dragstart", function(){
                ui.startMoving(options.image);
            });

            card.getComponent = function(){
                return image;
            };

            card.getModel = function(){
                return { card_id: options.image };
            };

            card.getPoints = function () {
                return {
                    top:image.getY(),
                    left:image.getX(),
                    right:image.getX() + image.getWidth(),
                    bottom:image.getY() + image.getHeight()
                };
            };
            card.onCollisionStart = function () {
            };
            card.onCollisionStop = function () {
            };
            card.onCollisionAccepted = function(){
            };

            card.onNoCollisionFound = function(){
                ui.droppedOut(options.image);
                return true;
            };

            card.destroy = function(){
                stage.remove(card);
            };


            CardGame.Collisionable(stage, card);

            stage.add(card);

            return card;
        };


        window.onload = function() {
            var ui = CardGame.GameUI();
            var stage = CardGame.Stage(ui, {
                container: "container",
                width: 800,
                height: 800
            });

            ui.init([7, 17, 27]);
        };




    </script>
</head>
<body>
<div id="container"></div>
</body>
</html>
